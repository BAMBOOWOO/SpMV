\documentclass{article}
\input{packages}

\title{Short Paper - Template}
\author{Author}
\date{\today}

\begin{document}
\twocolumn
%------------------------------------------                                       
%                     Title
%------------------------------------------
[{
\LARGE
\textcolor{titleColor}{\textbf{CS531 Parallel Computing Homework3 report.}}\vspace{1ex}\\
%------------------------------------------                                       
%                    Authors
%------------------------------------------
\large
\textcolor{authorColor}{ChiaChing Wu}
\vspace{1ex}
%------------------------------------------                                                           
%                   Abstract
%------------------------------------------
\normalsize
\begin{tcolorbox}[  colback = abstractColor,
                    ,
                    width=\linewidth,
                    arc=1mm, auto outer arc,
                ]
\justifying
\begin{abstract}
    This report is based on my results of the five questions about coo and csr sparse matrix vector multiplication. I will explore and explain my try in this five questions.
\end{abstract}

\end{tcolorbox}
\vspace{1.5ex}
}]


%------------------------------------------
%                   Main Matter
%------------------------------------------

\section{Question 1}
For question 1, we asked to convert coo to csr, so I divided this question into three parts. The first part was calculating the number of non zero numbers in each row, and second part was to obtain the final csr ptr value. For the last part, due to coo being sorted by column, so I converted coo col and coo val with the csr ptr just obtained. To make it parallel, I tried histogram, I made an array with number of rows times number of threads, and combined the answers of each threads obtained with another for loop which can also be paralleled. However, for the second part and third part, I could not parallel it, because the second part was to determine the final value of csr ptr, which row number of each index added up with row number of last index, creating a true dependency. For the third part, I found that it had race condition and it didn't speed up with omp atmoic. Therefore, It took about 0.12 secs for serial and 0.08secs for parallel part with 16 threads. I think the improvement was not really noticeable, because I could only parallel the first part of the function.  
\section{Question 2 and 4}
For question 2 and 4, I think the serial part is the easiest one among these five functions, so basically I made a single for loop to traverse from zero to nnz-1 to obtain each col index, row index and val to compute with the value of vector[col-1]. The obtained value will store in the resvals[row-1]. For parallel part, I tried three ways. The first one was simply adding omp for and omp atomic, which is extremely slow, it took me 700 secs to finish the function. The second one was also histogram. Same way I have done in converting part. I made two loops, the first one is to store values for each thread, and the second loop is to combine all the values of each thread in each row. With 16 threads, this way could have performance 3x comparing with serial coo. For the second way, I found accumulating in memory typically slower than in registers, so instead of doing that way, I accumulated values until changing rows, and I did not need to initialize a new array with m times numbers of threads. Hence, it turned out I could have 3.8x performance comparing with serial part. 

\section{Question 3 and 5}
For question 3, I created a double for loops. The first for loop was from 0 to m-1, and the second for loop was based on the row number to determine the start index and end index, which start index was csr row ptr[i] and end index is csr row ptr[i+1]. Therefore, although it was a double for loop, it still traversed from 0 to nnz, which is linear. To parallel it, I tried two ways. The first one was adding omp parallel for to parallel row loop, which was really fast having 8x performance with 16 threads comparing with serial part. However, the second one was parallel column for loop, which was extremely slow. I thought it was because tasks are too fine grained.

\section{Conclusion}
I think homework 3 is by far the most interesting one and I learned how to use histogram to parallel, not just using omp parallel for with some speed up. 








 



\end{document}